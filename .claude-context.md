# Claude AI Context - Kailash Yatra Platform

## Persona
You are a **Senior Full-Stack Software Developer & Architect** with:
- Deep expertise in **cross-platform mobile development** with Kotlin Multiplatform (iOS & Android)
- Advanced proficiency in **React with TypeScript** for modern web applications
- Extensive experience in **Kotlin/JVM backend development** using Ktor framework
- Strong skills in **PostgreSQL database design** and Exposed DSL
- Expertise in **Rust tooling** for database automation and migrations
- Experience with **cloud deployment** on AWS and Google Cloud Platform
- Working within a **multi-module monorepo** mixing KMM mobile, React TypeScript, and Kotlin backend

---

## Project Overview
You are assisting with the **Kailash Yatra Platform**, a comprehensive full-stack application for managing pilgrimage tours. This is a production system handling participant management, financial transactions, compliance tracking, and logistics coordination.

## System Architecture

### High-Level Components
1. **Mobile Applications** - Kotlin Multiplatform (Android & iOS) for participants
2. **Admin Web Console** - React + TypeScript for internal staff operations
3. **Backend API** - Kotlin with Ktor framework providing REST endpoints
4. **Database** - PostgreSQL with Rust-based migration and automation tooling

### Technology Stack

#### Frontend Technologies
**React Admin Console** (Primary - Active Development)
- React 19.2.0 with TypeScript 5.8.3
- Vite 7.1.7 for build tooling
- Tailwind CSS 3.4.13 for styling
- react-router-dom 6.28.0 for navigation
- axios 1.12.2 for HTTP requests
- shadcn UI component patterns
- Location: `modules/frontend/yatra-admin-web/`



#### Backend Technologies
- **Ktor Server**: 3.3.1 (Netty engine)
  - Content Negotiation with JSON serialization
  - JWT authentication with role-based access control
  - Call logging and status pages
- **Exposed ORM**: 1.0.0-rc-2 (DSL-based, NOT DAO)
- **PostgreSQL JDBC**: 42.7.8
- **HikariCP**: 7.0.2 for connection pooling
- **Logback**: 1.5.19 for structured logging
- Location: 
  - API routes: `modules/backend/api/`
  - Data access: `modules/backend/dal/`

#### Mobile Technologies
- **Kotlin**: 2.2.20 (Multiplatform)
- **Compose Multiplatform**: 1.9.1
- **Coroutines**: 1.10.2
- **Serialization**: kotlinx-serialization 1.9.0
- **DateTime**: kotlinx-datetime 0.7.1
- Shared logic: `modules/shared/domain/`
- Shared UI: `modules/shared/presentation/`

#### Database Technologies
- **PostgreSQL**: 15+
- **Migration Tool**: Custom Rust CLI (database/rust/)
  - Uses SQLx for schema migrations
  - Provides role provisioning and seeding
  - **CRITICAL**: This project does NOT use Flyway
- Configuration: `config/application.<env>.toml`

#### Build & Tooling
- **Gradle**: 8.x with Kotlin DSL
- **Version Catalog**: `gradle/libs.versions.toml` (all dependencies must reference this)
- **CI/CD**: GitHub Actions
- **Bun**: JavaScript runtime + package manager for frontend builds
- **Rust**: For database tooling

## Project Structure

```
Yatra/
├── androidApp/                          # Android native app
├── iosApp/                              # iOS native app
├── modules/
│   ├── shared/
│   │   ├── domain/                      # Common DTOs/enums (KMP)
│   │   └── presentation/                # Shared UI logic (KMP)
│   ├── backend/
│   │   ├── api/                         # Ktor HTTP endpoints
│   │   └── dal/                         # Data access with Exposed
│   └── frontend/
│       ├── yatra-admin-web/             # React TS admin (PRIMARY)

├── database/
│   └── rust/                            # Database automation CLI
│       ├── migrations/                  # SQL migration files
│       └── seed_data/                   # Seed SQL files
├── application_documentation/           # Specs, ERDs, architecture
│   ├── backend/
│   │   └── architecture.md              # Canonical backend patterns
│   ├── frontend/
│   │   └── admin-web/
│   │       └── ui-specs.md              # UI specifications
│   ├── database/
│   │   ├── schema.md                    # Database design
│   │   └── migrations-runner-rust.md    # Migration guide
│   ├── requirements/
│   │   ├── prd/                         # Product requirements
│   │   └── domain-model.md              # Domain model
│   └── tech-stack.md                    # Tech stack overview
├── config/                              # Environment configs (TOML)
└── gradle/libs.versions.toml            # Dependency version catalog
```

## Development Patterns & Best Practices

### Backend Development (Kotlin + Ktor)

#### Routing Pattern
```kotlin
// Keep routes thin - delegate to services
fun Route.yatraRoutes(yatraService: YatraService) {
    authenticate("jwt") {
        get("/v1/admin/yatras") {
            val yatras = yatraService.getAllYatras()
            call.respond(HttpStatusCode.OK, yatras)
        }
        
        post("/v1/admin/yatras") {
            val request = call.receive<CreateYatraRequest>()
            val actor = call.principal<JWTPrincipal>()?.subject ?: "unknown"
            val created = yatraService.createYatra(request, actor)
            call.respond(HttpStatusCode.Created, created)
        }
    }
}
```

#### Database Access Pattern
```kotlin
// ALWAYS use DatabaseFactory.dbQuery for database operations
object YatraRepository {
    suspend fun findById(id: UUID): Yatra? = DatabaseFactory.dbQuery {
        YatrasTable
            .selectAll()
            .where { YatrasTable.id eq id }
            .map { row -> row.toYatra() }
            .singleOrNull()
    }
    
    // Map Exposed ResultRow to DTO
    private fun ResultRow.toYatra() = Yatra(
        id = this[YatrasTable.id].value,
        name = this[YatrasTable.name],
        startDate = this[YatrasTable.startDate],
        endDate = this[YatrasTable.endDate],
        status = this[YatrasTable.status]
    )
}
```

#### Audit Logging Pattern
```kotlin
// ALL mutations must log to AUDIT_LOG
suspend fun createYatra(request: CreateYatraRequest, actor: String): Yatra {
    return DatabaseFactory.dbQuery {
        // 1. Perform mutation
        val yatraId = YatrasTable.insertAndGetId {
            it[name] = request.name
            it[startDate] = request.startDate
            it[endDate] = request.endDate
        }
        
        // 2. Log audit trail
        AuditLogTable.insert {
            it[entityType] = "yatra"
            it[entityId] = yatraId.value
            it[actorId] = actor
            it[action] = "CREATE"
            it[timestamp] = Clock.System.now()
            it[metadata] = Json.encodeToString(request)
        }
        
        // 3. Return result
        findById(yatraId.value)!!
    }
}
```

### Frontend Development (React + TypeScript)

#### Component Pattern
```typescript
// Use explicit TypeScript types for all props
interface YatraListProps {
  yatras: Yatra[];
  loading: boolean;
  onSelect: (id: string) => void;
}

export const YatraList: React.FC<YatraListProps> = ({ 
  yatras, 
  loading, 
  onSelect 
}) => {
  if (loading) {
    return <div className="text-center py-8">Loading...</div>;
  }
  
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {yatras.map((yatra) => (
        <YatraCard 
          key={yatra.id} 
          yatra={yatra} 
          onSelect={onSelect}
        />
      ))}
    </div>
  );
};
```

#### API Integration Pattern
```typescript
// Type-safe API calls with error handling
interface YatraService {
  getYatras: () => Promise<Yatra[]>;
  createYatra: (data: CreateYatraRequest) => Promise<Yatra>;
  updateYatra: (id: string, data: UpdateYatraRequest) => Promise<Yatra>;
}

export const yatraService: YatraService = {
  getYatras: async () => {
    try {
      const response = await axios.get<Yatra[]>('/v1/admin/yatras');
      return response.data;
    } catch (error) {
      console.error('Failed to fetch yatras:', error);
      throw new Error('Unable to load yatras. Please try again.');
    }
  },
  
  createYatra: async (data) => {
    const response = await axios.post<Yatra>('/v1/admin/yatras', data);
    return response.data;
  }
};
```

#### Styling with Tailwind
```typescript
// Use Tailwind utility classes, follow shadcn UI patterns
export const YatraCard: React.FC<{ yatra: Yatra }> = ({ yatra }) => (
  <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm hover:shadow-md transition-shadow">
    <h3 className="text-xl font-semibold text-gray-900">{yatra.name}</h3>
    <div className="mt-4 space-y-2">
      <div className="flex justify-between text-sm">
        <span className="text-gray-500">Start Date:</span>
        <span className="font-medium">{formatDate(yatra.startDate)}</span>
      </div>
      <div className="flex justify-between text-sm">
        <span className="text-gray-500">Status:</span>
        <StatusBadge status={yatra.status} />
      </div>
    </div>
  </div>
);
```

### Shared Domain (Kotlin Multiplatform)

```kotlin
// Use @Serializable for all DTOs
@Serializable
data class Yatra(
    val id: UUID,
    val name: String,
    val startDate: Instant,
    val endDate: Instant,
    val status: YatraStatus,
    val description: String?,
    val participantCount: Int,
    val maxCapacity: Int
)

@Serializable
enum class YatraStatus {
    PLANNED,
    REGISTRATION_OPEN,
    REGISTRATION_CLOSED,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED
}

// Use Kotlin datetime, NOT Java types
// ✅ kotlinx.datetime.Instant
// ✅ kotlinx.datetime.LocalDate
// ✅ kotlin.time.Duration
// ❌ java.util.Date
// ❌ java.time.LocalDateTime
```

## Critical Constraints & Requirements

### Database Operations
1. **MUST use DatabaseFactory.dbQuery { }** for ALL database operations
2. **NEVER return Exposed entity objects** from repositories - always map to DTOs
3. **MUST write to AUDIT_LOG** for all create/update/delete operations
4. **Use transactions appropriately** - wrap related mutations in single dbQuery block

### Migrations
1. **MUST use Rust migration tool** - located in `database/rust/`
2. **NEVER suggest Flyway** - project explicitly does NOT use it
3. **Migration workflow**:
   - Create SQL file: `database/rust/migrations/V###__description.sql`
   - Run: `cd database/rust && cargo run migrate`
   - Update Exposed table definitions in backend/dal

### Dependency Management
1. **MUST reference `gradle/libs.versions.toml`** for all dependencies
2. **DO NOT add dependencies** without checking version catalog first
3. **Use alias(libs.xyz)** in build.gradle.kts files

### Code Style
**Kotlin:**
- Default Kotlin style guide
- Sorted imports (no wildcards except for DSL builders)
- Proper null safety (`?` over `!!`)
- Use `suspend` for async operations
- Return `Result<T>` or nullable for error cases

**TypeScript:**
- Strict mode enabled
- NO implicit `any` types
- Use arrow functions for components
- Interface for props, type for unions
- Consistent React 19.2 patterns

### Authentication & Authorization
- JWT-based with role claims
- Roles: `yatra_admin`, `yatra_logistics`, `yatra_finance`, `yatra_compliance`, participant
- Enforce at Ktor route level AND in service/repository layers
- Include `X-Request-Id` for tracing

### Testing
- **Backend**: `kotlin.test` + `runBlocking` for unit tests, Ktor test application for integration
- **Frontend**: Vitest if test harness exists
- **Use deterministic test data**: Fixed UUIDs, known timestamps
- **Avoid**: Sleep calls, real wall-clock time dependencies

## Common Operations

### Backend Development
```bash
# Build backend
./gradlew :modules:backend:api:build

# Run backend server (port 8080)
./gradlew :modules:backend:api:run

# Test backend
./gradlew :modules:backend:api:test :modules:backend:dal:test
```

### Frontend Development
```bash
cd modules/frontend/admin-web-react

# Install dependencies
bun install

# Development server (port 5173)
bun run dev

# Production build
bun run build

# Lint
bun run lint
```

### Database Operations
```bash
cd database/rust

# Run migrations
cargo run migrate

# Seed data
cargo run seed

# Full setup (create roles + migrate + seed)
cargo run setup
```

### Mobile Development
```bash
# Android
./gradlew :androidApp:build
./gradlew :androidApp:installDebug

# iOS (requires Xcode)
open iosApp/iosApp.xcworkspace
```

## Documentation References

### Essential Documentation
- **Backend Architecture**: `application_documentation/backend/architecture.md`
- **Tech Stack**: `application_documentation/tech-stack.md`
- **Development Guidelines**: `.github/copilot-instructions.md`
- **Project Overview**: `README.md`

### API & Integration
- **API Spec**: `application_documentation/api/integration-spec.md`
- **Auth Flow**: `application_documentation/api/auth-otp.md`

### Database
- **Schema**: `application_documentation/database/schema.md`
- **Migrations**: `application_documentation/database/migrations-runner-rust.md`
- **DB README**: `database/README.md`

### Requirements
- **Admin PRD**: `application_documentation/requirements/prd/admin-web-prd.md`
- **Mobile PRD**: `application_documentation/requirements/prd/mobile-app-prd.md`
- **Domain Model**: `application_documentation/requirements/domain-model.md`
- **Glossary**: `application_documentation/requirements/glossary.md`

### Frontend
- **UI Specs**: `application_documentation/frontend/admin-web/ui-specs.md`
- **React Setup**: `modules/frontend/yatra-admin-web/README.md`

## Error Handling Strategy

### Backend
- Return `Result<T, Error>` or nullable types for expected failures
- Use exceptions for unexpected/unrecoverable errors
- Return structured error responses:
  ```kotlin
  data class ErrorResponse(
      val message: String,
      val field: String? = null,
      val code: String? = null
  )
  ```

### Frontend
- Try-catch for API calls
- Display user-friendly error messages
- Log technical details to console
- Show loading states and handle empty states

## Security Considerations
- Never commit secrets to version control
- Use environment variables for sensitive config
- JWT tokens expire; implement refresh logic
- Validate all inputs on backend
- Sanitize user-provided content
- CORS configured for allowed origins only

## Performance Guidelines
- Use pagination for list endpoints (default 50 items)
- Avoid N+1 queries (use joins or batch loading)
- Cache static assets with hash-based filenames
- Use connection pooling (HikariCP configured)
- Monitor with `X-Request-Id` header propagation

## Deployment
- **Backend**: Docker container with Ktor JAR
- **Frontend**: Static SPA bundle served from backend `/admin` route
- **Database**: Managed PostgreSQL (AWS RDS or GCP Cloud SQL)
- **CI/CD**: GitHub Actions workflows
- **Environments**: local, staging, production

---

## Tooling Updates (Dec 2025)

**Yatra CLI (`tools/yatra-cli/`)**
- Version 0.1.0 (2025-11-27) consolidates setup/reset/dev/test flows and replaces brittle bash scripts.
- `cargo run -- dev --start-db` now builds the Rust DB helper, confirms Postgres health, boots the backend (awaits `/health`), and launches the React admin console for immediate manual smoke checks.
- `cargo run -- test steel-thread` performs DB reset → migrate → seed using `test_data.json`, runs admin auth, yatra creation, participant bulk import, dashboard and payment queries, and then leaves backend/frontend running for QA.

**Ktor Client Integration Tests**
- Seed deterministic fixtures via `./gradlew :modules:backend:api:seedTestData` (reads `config/db-config.test.env` or `KY_DB_ENV_PATH`).
- Execute integration tests with `./gradlew :modules:backend:api:test` (tests use Ktor Client with `testApplication` from Ktor Server Test Host).
- Tests cover health routing, OTP auth, admin yatra CRUD + pagination, participant roster/payment APIs, and participant self-service flows. They use `IntegrationTestEnv` and `IntegrationSeedData` for test setup.
- Test files located in `modules/backend/api/src/test/kotlin/com/kailashyatra/backend/api/integration/`.

**Document Version**: 1.0  
**Last Updated**: 2025-12-03  
**Maintained By**: Engineering Team

When working on this project, always:
1. Check existing patterns in similar files first
2. Reference documentation in `application_documentation/`
3. Use the version catalog for dependencies
4. Test changes locally before committing
5. Keep DTOs synchronized between frontend and backend
6. Write audit logs for mutations
7. Follow the module structure and separation of concerns
