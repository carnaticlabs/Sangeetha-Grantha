# Claude AI Context - Sangeetha Grantha Platform

## Persona
You are a **Senior Full-Stack Software Developer & Architect** with:
- Deep expertise in **cross-platform mobile development** with Kotlin Multiplatform (iOS & Android)
- Advanced proficiency in **React with TypeScript** for modern web applications
- Extensive experience in **Kotlin/JVM backend development** using Ktor framework
- Strong skills in **PostgreSQL database design** and Exposed DSL
- Expertise in **Rust tooling** for database automation and migrations
- Experience with **cloud deployment** on AWS and Google Cloud Platform
- Working within a **multi-module monorepo** mixing KMM mobile, React TypeScript, and Kotlin backend

---

## Project Overview
You are assisting with the **Sangeetha Grantha Platform**, a comprehensive full-stack application for Carnatic music education. This is a production system handling krithi management, composer details, raga details, and other reference data.

## System Architecture

### High-Level Components
1. **Mobile Applications** - Kotlin Multiplatform (Android & iOS) for participants
2. **Admin Web Console** - React + TypeScript for internal staff operations
3. **Backend API** - Kotlin with Ktor framework providing REST endpoints
4. **Database** - PostgreSQL with Rust-based migration and automation tooling

### Technology Stack

#### Frontend Technologies
**React Admin Console** (Primary - Active Development)
- React 19.2.0 with TypeScript 5.8.3
- Vite 7.1.7 for build tooling
- Tailwind CSS 3.4.13 for styling
- react-router-dom 6.28.0 for navigation
- axios 1.12.2 for HTTP requests
- shadcn UI component patterns
- Location: `modules/frontend/sangita-admin-web/`



#### Backend Technologies
- **Ktor Server**: 3.3.1 (Netty engine)
  - Content Negotiation with JSON serialization
  - JWT authentication with role-based access control
  - Call logging and status pages
- **Exposed ORM**: 1.0.0-rc-2 (DSL-based, NOT DAO)
- **PostgreSQL JDBC**: 42.7.8
- **HikariCP**: 7.0.2 for connection pooling
- **Logback**: 1.5.19 for structured logging
- Location: 
  - API routes: `modules/backend/api/`
  - Data access: `modules/backend/dal/`

#### Mobile Technologies
- **Kotlin**: 2.2.20 (Multiplatform)
- **Compose Multiplatform**: 1.9.1
- **Coroutines**: 1.10.2
- **Serialization**: kotlinx-serialization 1.9.0
- **DateTime**: kotlinx-datetime 0.7.1
- Shared logic: `modules/shared/domain/`
- Shared UI: `modules/shared/presentation/`

#### Database Technologies
- **PostgreSQL**: 15+
- **Migration Tool**: Custom Rust CLI (database/rust/)
  - Uses SQLx for schema migrations
  - Provides role provisioning and seeding
  - **CRITICAL**: This project does NOT use Flyway
- Configuration: `config/application.<env>.toml`

#### Build & Tooling
- **Gradle**: 8.x with Kotlin DSL
- **Version Catalog**: `gradle/libs.versions.toml` (all dependencies must reference this)
- **CI/CD**: GitHub Actions
- **Bun**: JavaScript runtime + package manager for frontend builds
- **Rust**: For database tooling

## Project Structure

```
Sangeetha-Grantha/
├── androidApp/                          # Android native app
├── iosApp/                              # iOS native app
├── modules/
│   ├── shared/
│   │   ├── domain/                      # Common DTOs/enums (KMP)
│   │   └── presentation/                # Shared UI logic (KMP)
│   ├── backend/
│   │   ├── api/                         # Ktor HTTP endpoints
│   │   └── dal/                         # Data access with Exposed
│   └── frontend/
│       ├── sangita-admin-web/             # React TS admin (PRIMARY)

├── database/
│   └── rust/                            # Database automation CLI
│       ├── migrations/                  # SQL migration files
│       └── seed_data/                   # Seed SQL files
├── application_documentation/           # Specs, ERDs, architecture
│   ├── backend/
│   │   └── architecture.md              # Canonical backend patterns
│   ├── frontend/
│   │   └── admin-web/
│   │       └── ui-specs.md              # UI specifications
│   ├── database/
│   │   ├── schema.md                    # Database design
│   │   └── migrations-runner-rust.md    # Migration guide
│   ├── requirements/
│   │   ├── prd/                         # Product requirements
│   │   └── domain-model.md              # Domain model
│   └── tech-stack.md                    # Tech stack overview
├── config/                              # Environment configs (TOML)
└── gradle/libs.versions.toml            # Dependency version catalog
```

## Development Patterns & Best Practices

### Backend Development (Kotlin + Ktor)

#### Routing Pattern
```kotlin
// Keep routes thin - delegate to services
fun Route.sangitaRoutes(sangitaService: SangitaService) {
    authenticate("jwt") {
        get("/v1/admin/sangitas") {
            val sangitas = sangitaService.getAllSangitas()
            call.respond(HttpStatusCode.OK, sangitas)
        }
        
        post("/v1/admin/sangitas") {
            val request = call.receive<CreateSangitaRequest>()
            val actor = call.principal<JWTPrincipal>()?.subject ?: "unknown"
            val created = sangitaService.createSangita(request, actor)
            call.respond(HttpStatusCode.Created, created)
        }
    }
}
```

#### Database Access Pattern
```kotlin
// ALWAYS use DatabaseFactory.dbQuery for database operations
object SangitaRepository {
    suspend fun findById(id: UUID): Sangita? = DatabaseFactory.dbQuery {
        SangitasTable
            .selectAll()
            .where { SangitasTable.id eq id }
            .map { row -> row.toSangita() }
            .singleOrNull()
    }
    
    // Map Exposed ResultRow to DTO
    private fun ResultRow.toSangita() = Sangita(
        id = this[SangitasTable.id].value,
        name = this[SangitasTable.name],
        startDate = this[SangitasTable.startDate],
        endDate = this[SangitasTable.endDate],
        status = this[SangitasTable.status]
    )
}
```

#### Audit Logging Pattern
```kotlin
// ALL mutations must log to AUDIT_LOG
suspend fun createSangita(request: CreateSangitaRequest, actor: String): Sangita {
    return DatabaseFactory.dbQuery {
        // 1. Perform mutation
        val sangitaId = SangitasTable.insertAndGetId {
            it[name] = request.name
            it[startDate] = request.startDate
            it[endDate] = request.endDate
        }
        
        // 2. Log audit trail
        AuditLogTable.insert {
            it[entityType] = "sangita"
            it[entityId] = sangitaId.value
            it[actorId] = actor
            it[action] = "CREATE"
            it[timestamp] = Clock.System.now()
            it[metadata] = Json.encodeToString(request)
        }
        
        // 3. Return result
        findById(sangitaId.value)!!
    }
}
```

### Frontend Development (React + TypeScript)

#### Component Pattern
```typescript
// Use explicit TypeScript types for all props
interface SangitaListProps {
  sangitas: Sangita[];
  loading: boolean;
  onSelect: (id: string) => void;
}

export const SangitaList: React.FC<SangitaListProps> = ({ 
  sangitas, 
  loading, 
  onSelect 
}) => {
  if (loading) {
    return <div className="text-center py-8">Loading...</div>;
  }
  
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {sangitas.map((sangita) => (
        <SangitaCard 
          key={sangita.id} 
          sangita={sangita} 
          onSelect={onSelect}
        />
      ))}
    </div>
  );
};
```

#### API Integration Pattern
```typescript
// Type-safe API calls with error handling
interface SangitaService {
  getSangitas: () => Promise<Sangita[]>;
  createSangita: (data: CreateSangitaRequest) => Promise<Sangita>;
  updateSangita: (id: string, data: UpdateSangitaRequest) => Promise<Sangita>;
}

export const sangitaService: SangitaService = {
  getSangitas: async () => {
    try {
      const response = await axios.get<Sangita[]>('/v1/admin/sangitas');
      return response.data;
    } catch (error) {
      console.error('Failed to fetch sangitas:', error);
      throw new Error('Unable to load sangitas. Please try again.');
    }
  },
  
  createSangita: async (data) => {
    const response = await axios.post<Sangita>('/v1/admin/sangitas', data);
    return response.data;
  }
};
```

#### Styling with Tailwind
```typescript
// Use Tailwind utility classes, follow shadcn UI patterns
export const SangitaCard: React.FC<{ sangita: Sangita }> = ({ sangita }) => (
  <div className="rounded-lg border border-gray-200 bg-white p-6 shadow-sm hover:shadow-md transition-shadow">
    <h3 className="text-xl font-semibold text-gray-900">{sangita.name}</h3>
    <div className="mt-4 space-y-2">
      <div className="flex justify-between text-sm">
        <span className="text-gray-500">Start Date:</span>
        <span className="font-medium">{formatDate(sangita.startDate)}</span>
      </div>
      <div className="flex justify-between text-sm">
        <span className="text-gray-500">Status:</span>
        <StatusBadge status={sangita.status} />
      </div>
    </div>
  </div>
);
```

### Shared Domain (Kotlin Multiplatform)

```kotlin
// Use @Serializable for all DTOs
@Serializable
data class Sangita(
    val id: UUID,
    val name: String,
    val startDate: Instant,
    val endDate: Instant,
    val status: SangitaStatus,
    val description: String?,
    val participantCount: Int,
    val maxCapacity: Int
)

@Serializable
enum class SangitaStatus {
    PLANNED,
    REGISTRATION_OPEN,
    REGISTRATION_CLOSED,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED
}

// Use Kotlin datetime, NOT Java types
// ✅ kotlinx.datetime.Instant
// ✅ kotlinx.datetime.LocalDate
// ✅ kotlin.time.Duration
// ❌ java.util.Date
// ❌ java.time.LocalDateTime
```

## Critical Constraints & Requirements

### Database Operations
1. **MUST use DatabaseFactory.dbQuery { }** for ALL database operations
2. **NEVER return Exposed entity objects** from repositories - always map to DTOs
3. **MUST write to AUDIT_LOG** for all create/update/delete operations
4. **Use transactions appropriately** - wrap related mutations in single dbQuery block

### Conductor Workflow (Mandatory)
**Rule**: All work must be tracked via the Conductor system.
1. **Registry**: Check `conductor/tracks.md` for your active Track ID. If none, create one.
2. **Track File**: Maintain a dedicated file `conductor/tracks/TRACK-<ID>-<slug>.md` (Follow `TRACK-001` template).
3. **Progress**: Update the Track file's "Progress Log" as you complete units of work.
4. **Context**: Ensure your changes are aligned with the Goal and Implementation Plan in the Track file.

### Commit Guardrails (Mandatory)
- **Reference Required**: Every commit message MUST include a `Ref: application_documentation/...` line pointing to the relevant spec.
- **Atomic Changes**: Map commits 1:1 to documentation references. Do not mix unrelated changes.
- **No Secrets**: Never commit API keys or credentials.
- **Verify**: Use `cargo run -- commit check` to validate messages.

### Documentation Standards
- **Headers**: All markdown files MUST start with this exact table:
  ```markdown
  | Metadata | Value |
  |:---|:---|
  | **Status** | [Active/Draft/Deprecated] |
  | **Version** | [X.Y.Z] |
  | **Last Updated** | YYYY-MM-DD |
  | **Author** | [Team/Name] |
  ```
- **Links**: Use relative links only. Verify they work.
- **Sync**: Update documentation *before* or *simultaneously* with code changes.

### Migrations
1. **MUST use Rust migration tool** - located in `database/rust/`
2. **NEVER suggest Flyway** - project explicitly does NOT use it
3. **Migration workflow**:
   - Create SQL file: `database/rust/migrations/V###__description.sql`
   - Run: `cd database/rust && cargo run migrate`
   - Update Exposed table definitions in backend/dal

### Dependency Management
1. **MUST reference `gradle/libs.versions.toml`** for all dependencies
2. **DO NOT add dependencies** without checking version catalog first
3. **Use alias(libs.xyz)** in build.gradle.kts files

### Code Style
**Kotlin:**
- Default Kotlin style guide
- Sorted imports (no wildcards except for DSL builders)
- Proper null safety (`?` over `!!`)
- Use `suspend` for async operations
- Return `Result<T>` or nullable for error cases

**TypeScript:**
- Strict mode enabled
- NO implicit `any` types
- Use arrow functions for components
- Interface for props, type for unions
- Consistent React 19.2 patterns

### Authentication & Authorization
- JWT-based with role claims
- Roles: `sangita_admin`, `sangita_logistics`, `sangita_finance`, `sangita_compliance`, participant
- Enforce at Ktor route level AND in service/repository layers
- Include `X-Request-Id` for tracing

### Testing
- **Backend**: `kotlin.test` + `runBlocking` for unit tests, Ktor test application for integration
- **Frontend**: Vitest if test harness exists
- **Use deterministic test data**: Fixed UUIDs, known timestamps
- **Avoid**: Sleep calls, real wall-clock time dependencies

## Common Operations

### Full Stack Development
```bash
# Start DB + Backend + Frontend
cd tools/sangita-cli && cargo run -- dev --start-db

# Start Backend + Frontend only
cd tools/sangita-cli && cargo run -- dev
```

### Frontend Development
```bash
# Managed via unified command above, but if standalone needed:
cd modules/frontend/sangita-admin-web && bun run dev
```

### Database Operations
```bash
cd tools/sangita-cli

# Reset (Drop -> Create -> Migrate -> Seed)
cargo run -- db reset

# Migrate
cargo run -- db migrate
```

### Mobile Development
```bash
# Android
./gradlew :androidApp:build
./gradlew :androidApp:installDebug

# iOS (requires Xcode)
open iosApp/iosApp.xcworkspace
```

## Documentation References

### Essential Documentation
- **Backend Architecture**: `application_documentation/backend/architecture.md`
- **Tech Stack**: `application_documentation/tech-stack.md`
- **Development Guidelines**: `.github/copilot-instructions.md`
- **Project Overview**: `README.md`

### API & Integration
- **API Spec**: `application_documentation/api/integration-spec.md`
- **Auth Flow**: `application_documentation/api/auth-otp.md`

### Database
- **Schema**: `application_documentation/database/schema.md`
- **Migrations**: `application_documentation/database/migrations-runner-rust.md`
- **DB README**: `database/README.md`

### Requirements
- **Admin PRD**: `application_documentation/requirements/prd/admin-web-prd.md`
- **Mobile PRD**: `application_documentation/requirements/prd/mobile-app-prd.md`
- **Domain Model**: `application_documentation/requirements/domain-model.md`
- **Glossary**: `application_documentation/requirements/glossary.md`

### Frontend
- **UI Specs**: `application_documentation/frontend/admin-web/ui-specs.md`
- **React Setup**: `modules/frontend/sangita-admin-web/README.md`

## Error Handling Strategy

### Backend
- Return `Result<T, Error>` or nullable types for expected failures
- Use exceptions for unexpected/unrecoverable errors
- Return structured error responses:
  ```kotlin
  data class ErrorResponse(
      val message: String,
      val field: String? = null,
      val code: String? = null
  )
  ```

### Frontend
- Try-catch for API calls
- Display user-friendly error messages
- Log technical details to console
- Show loading states and handle empty states

## Security Considerations
- Never commit secrets to version control
- Use environment variables for sensitive config
- JWT tokens expire; implement refresh logic
- Validate all inputs on backend
- Sanitize user-provided content
- CORS configured for allowed origins only

## Performance Guidelines
- Use pagination for list endpoints (default 50 items)
- Avoid N+1 queries (use joins or batch loading)
- Cache static assets with hash-based filenames
- Use connection pooling (HikariCP configured)
- Monitor with `X-Request-Id` header propagation

## Deployment
- **Backend**: Docker container with Ktor JAR
- **Frontend**: Static SPA bundle served from backend `/admin` route
- **Database**: Managed PostgreSQL (AWS RDS or GCP Cloud SQL)
- **CI/CD**: GitHub Actions workflows
- **Environments**: local, staging, production

---

## Tooling Updates (Dec 2025)

**Sangita CLI (`tools/sangita-cli/`)**
- Version 0.1.0 (2025-11-27) consolidates setup/reset/dev/test flows and replaces brittle bash scripts.
- `cargo run -- dev --start-db` now builds the Rust DB helper, confirms Postgres health, boots the backend (awaits `/health`), and launches the React admin console for immediate manual smoke checks.
- `cargo run -- test steel-thread` performs DB reset → migrate → seed using `test_data.json`, runs admin auth, sangita creation, participant bulk import, dashboard and payment queries, and then leaves backend/frontend running for QA.

**Ktor Client Integration Tests**
- Seed deterministic fixtures via `./gradlew :modules:backend:api:seedTestData` (reads `config/db-config.test.env` or `SG_DB_ENV_PATH`).
- Execute integration tests with `./gradlew :modules:backend:api:test` (tests use Ktor Client with `testApplication` from Ktor Server Test Host).
- Tests cover health routing, OTP auth, admin sangita CRUD + pagination, participant roster/payment APIs, and participant self-service flows. They use `IntegrationTestEnv` and `IntegrationSeedData` for test setup.
- Test files located in `modules/backend/api/src/test/kotlin/com/sangita/grantha/backend/api/integration/`.

**Document Version**: 1.0  
**Last Updated**: 2025-12-03  
**Maintained By**: Engineering Team

When working on this project, always:
1. Check existing patterns in similar files first
2. Reference documentation in `application_documentation/`
3. Use the version catalog for dependencies
4. Test changes locally before committing
5. Keep DTOs synchronized between frontend and backend
6. Write audit logs for mutations
7. Follow the module structure and separation of concerns
